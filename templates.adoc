## Lab: Using Templates

### Application description
In this lab, we're going to deploy a complete backend application, consisting of
an REST API backend and a mongo database. The complete application will already
be wired together and described as a backend for the map visualization tool, so
that once the application is build and deployed, you will be able to see the new
map.

image::roadshow-app-architecture-nationalparks-2.png[Application architecture,800,align="center"]

### Background: Templates
Running all these individual commands can be tedious and error prone.
Fortunately for you, all of this configuration can be put together into a single
*Template* which can then be processed to create a full set of resources. As you
saw with MongoDB, a *Template* may define parameters for certain values, such as
DB username or password, and they can be automatically generated by OpenShift at
processing time.

Administrators can load *Templates* into OpenShift and make them available to
all users, even via the web console. Users can create *Templates* and load them
into their own *Projects* for other users (with access) to share and use.

The great thing about *Templates* is that they can speed up the deployment
workflow for application development by providing a "recipe" of sorts that can
be deployed with a single command.  Not only that, they can be loaded into
OpenShift from an external URL, which will allow you to keep your templates in a
version control system. And, even further, they can be stored in a version
control system (even in the same repository as the application source code) --
they're just serialized text data!

Let's combine all of the exercises we have performed in the last several labs by
using a *Template* that we can instantiate with a single command.  While we
could have used templates to deploy everything in the workshop today, remember
that it is important for you to understand how to create, deploy, and wire
resources together.

#### Exercise: Instantiate a Template

We've deployed our Nationalparks application in our development environment.
Now we would like to deploy the same stack into production.
We don't want to repeat ourselves, so we've created a Template of our stack.

Deploy the template with a suffix "-live" to differentiate the Dev & Live stacks.

[NOTE]
====
A better solution would be to create seperate projects for the different
application lifecycle stages (Dev, Test, Acc, Prod).
But after all, this is just a workshop.
====

It also uses a *Hook* to call the `/ws/data/load` endpoint to cause the data 
to be loaded into the database from a JSON file in the source code repository. 
Execute the following command:

[source]
----
{% if PARKSMAP_PY %}
oc create -f https://raw.githubusercontent.com/openshift-roadshow/nationalparks/{{NATIONALPARKS_VERSION}}/ose3/deployment-template.json
{% else %}
oc create -f https://raw.githubusercontent.com/openshift-roadshow/nationalparks/{{NATIONALPARKS_VERSION}}/ose3/deployment-template.json
{% endif %}
----

What just happened? What did you just `create`? The item that we passed to the `create`
command is a *Template*. `create` simply makes the template available in
your *Project*. You can see this with the following command:

[source]
----
oc get template
----

You will see output like the following:

[source]
----
{% if PARKSMAP_PY %}
NAME            DESCRIPTION                                                                        PARAMETERS     OBJECTS
nationalparks   Application template NationalParks backend running on SpringBoot and using mo...   15 (5 blank)   5
{% else %}
nationalparks   Application template NationalParks backend running on SpringBoot and using mo...   15 (5 blank)   5
{% endif %}
----

Are you ready for the magic command?  Here it is:

{% if USE_MAVEN %}
[source]
----
oc new-app --template=nationalparks -p APPLICATION_STAGE=live 
----

{% else %}
[source]
----
{% if PARKSMAP_PY %}
oc new-app --template=nationalparks -p APPLICATION_STAGE=live 
{% else %}
oc new-app --template=nationalparks -p APPLICATION_STAGE=live 
{% endif %}
----
{% endif %}

You will see the following output:

[source]
----
--> Deploying template "explore-000/nationalparks" to project explore-000

     nationalparks
     ---------
     Application template NationalParks backend running on SpringBoot and using mongodb

     * With parameters:
        * Application Name=nationalparks
        * Application Lifecycle stage=live
        * Application route=
        * Mongodb App=mongodb
        * Git source repository=https://github.com/openshift-roadshow/nationalparks.git
        * Git branch/tag reference=master
        * Maven mirror url=
        * Database name=mongodb
        * MONGODB_NOPREALLOC=
        * MONGODB_SMALLFILES=
        * MONGODB_QUIET=
        * Database user name=mongodb
        * Database user password=mongodb
        * Database admin password=mongodb
        * GitHub Trigger=C3fbvG5y # generated
        * Generic Trigger=EsDsBag0 # generated

--> Creating resources ...
    service "mongodb-live" created
    deploymentconfig "mongodb-live" created
    deploymentconfig "nationalparks-live" created
    service "nationalparks-live" created
    route "nationalparks-live" created
--> Success
    Run 'oc status' to view your app.
----

OpenShift will now:

* Configure and deploy MongoDB
** Using auto-generated user, password, and database name
* Configure environment variables for the app to connect to the DB
* Create the correct services
* Label the app service with `type=parksmap-backend`

All with one command!

Think about how
this could be used in your environment.  For example, a template could define a
large set of resources that make up a "reference application", complete with
several app servers, databases, and more.  You could deploy the entire set of
resources with one command, and then hack on them to develop new features,
microservices, fix bugs, and more.

As a last exercise, look at the template that was used to create the
resources for our *nationalparks-live* application.

[source]
----
{% if PARKSMAP_PY %}
oc get template nationalparks -o yaml
{% else %}
oc get template nationalparks -o yaml
{% endif %}
----


#### Label Service
As discussed in link:databases[previous labs], the `parksmap` web app queries the OpenShift API and
looks for routes that have the label `type=parksmap-backend` and interrogates the
discovered endpoints to visualize their map data. After creating the "live" app,
`parksmap` should use the *Live* container instead of the *Dev* container so that
deployments to the *Dev* container does not disrupt the `parksmap` application.
You can do that by removing the `type` label from the *Dev* route and adding it
to the *Live* route:

[source]
----
oc label route nationalparks type-
oc label route nationalparks-live type=parksmap-backend
----

#### Tag to deploy

Notice that the `nationalparks-live` hasn't started a deployment.
This is because there are no images tagged with our `${APPLICATION_STAGE}` (live).

